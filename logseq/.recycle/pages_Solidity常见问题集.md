- 函数的可见性和修饰符
	- 函数可以用
		- `private` 只能当前合约内部调用
		- `internal`当前合约和子合约调用
		- `public`内部和外部都可以调用，相对与`external`会花费更多的 gas fee
		- `external`只能外部调用
	- 为什么 `public`比`external` Gas 消耗高？
		- `public`在调用时，会将所有的参数复制到堆栈，在执行时和完成后会清理堆栈，这会导致更多的gas 消耗
			- public 处理过程`calldatacopy` -> `pop``push``swap`->`mstore`
- 操作码
	- CREATE
		- CREATE：调用者者地址 + nonce 进行hash，计算新合约的地址
			- 数据准备：调用者向北创建的合约传递数据和ETH
			- 合约创建：EVM 创建新的合约，并将数据存储在合约的 data存储中
			- 返回地址：创建完成后，通过 `CREATE`操作码返回新合约地址
		- CREATE2：
			- 数据准备：同`CREATE`
			- 合约创建：同`create`
			- 返回地址：keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]
	- call/delegatecall
- 以太坊 gas fee 计算
	- 固定费率：gas price + gas used，最大 15M
	- 1155 费率：base fee + tip fee [[以太坊 Gas Fee 优化方案]] 最大 30M
- 随机数
	- 在计算机领域，随机数通常指的是 PRNG 伪随机数生成器、PRNG 通过初始的种子值生成随机数序列。所以种子的选择至关重要
	- 在EVM 中，本质上是无法安全的产生伪随机数。因为在一个合约调用中，随机种子值只能从外部的几个变量中组合，例如 blocknumber、timestamp、nonce等，这些都可以在合约调用前通过输出参数穷举出来。
	- 在随机数要求较高的场景下，一般用可验证随机数方案提升随机性，例如 chainlink 的 VRF。本质上是通过预言机将随机种子用回调的方式推送到合约中，然后执行业务逻辑
- Stake Too Deep
	- 原因：EVM 的作用域内，栈内存最多可以引用 16 个变量
	- https://soliditydeveloper.com/stacktoodeep
	- 使用内部方法
	- 使用块级作用域
	- 使用 struct
- 发送 ETH
	- 发送
		- |method| gas fee | return | 
		  | `transfer` | 2300 | throws error|
		  | `send` | 2300 gas | return bool |
		  | `call` | 会传递 gas fee 到目标合约 | return bool |
		- 推荐用 call，当目标合约使用 receive 函数， transfer 和 send 可能会导致失败
	- 接收
		- receive() external payable：空的calldata 的时候会触发
		- fallback() external payable：没有匹配到 function 的时候会触发
- abi.encodePacked 为什么比 abi.encode 短？
	- abi.encode 会将每一个参数填充为32 bytes，对于动态数组，也会在数组之前包含一个数组长度，如下所示：
		- ```
		  abi.encodePacked(
		      address(0x4200000000000000000000000000000000000015),
		      uint256(15),
		      [1, 2],
		      [4, 5, 6],
		      "Hello"
		  );
		  abi.encodePacked(
		      address(0x4200000000000000000000000000000000000015),
		      uint256(1),
		      [1, 2],
		      [4, 5, 6],
		      "Hello"
		  );
		  
		  // result
		  0000000000000000000000004200000000000000000000000000000000000015
		  0000000000000000000000000000000000000000000000000000000000000001
		  0000000000000000000000000000000000000000000000000000000000000002
		  0000000000000000000000000000000000000000000000000000000000000003
		  0000000000000000000000000000000000000000000000000000000000000005
		  0000000000000000000000000000000000000000000000000000000000000006
		  0000000000000000000000000000000000000000000000000000000000000007
		  0000000000000000000000000000000000000000000000000000000000000100
		  0000000000000000000000000000000000000000000000000000000000000005
		  48656c6c6f000000000000000000000000000000000000000000000000000000
		  
		  4200000000000000000000000000000000000015
		  0000000000000000000000000000000000000000000000000000000000000001
		  0000000000000000000000000000000000000000000000000000000000000002
		  0000000000000000000000000000000000000000000000000000000000000003
		  0000000000000000000000000000000000000000000000000000000000000005
		  0000000000000000000000000000000000000000000000000000000000000006
		  0000000000000000000000000000000000000000000000000000000000000007
		  48656c6c6f
		  ```
	- ⚠️ 整数都会以 32位 填充
- cold read 和 warm read
	- 冷读是指第一次读取变量，需要从内存中读取其值然后存储到堆栈，会消耗较高的 gas fee
	- Gas Calculation:
		- `gas_cost = 100` **if** `(context_addr, target_storage_key)` **in** `touched_storage_slots` (warm access)
		- `gas_cost = 2100` **if** `(context_addr, target_storage_key)` **not in** `touched_storage_slots` (cold access)
		  id:: 65a8e8a8-cbf0-4824-96e4-10feeb90587f
-
-