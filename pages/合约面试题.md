# 项目经验
	- ## 多签主钱包
		- Master：管理钱包的配置（合约地址），Owner 管理
		- Wallet：钱包主合约，持有资产，负责调用其他 NFT 合约进行资产转移
			- Static：负责扩展wallet 方法
		- Operator：负责操作钱包合约对 NFT合约进行调用，签名验证
	- ## 随机数和Chainlink VRF
		- 区块链随机数问题
		- Chainlink VRF 使用：发起随机器请求，Chainlink 回调并返回随机数
			- 问题1：Chainlink 回调式，会消耗gas fee，所以消费者需要提供 $LINK 代币
			- 问题2：Chainlink 提供了订阅模式，不需要每次请求随机数时转移 $LINK ，直接从订阅账户扣除 gas 成本
	- ## 合约升级
		- [升级模式](logseq://graph/logseq?block-id=65599941-3e6e-4fea-9126-eea11fedada4)
	- ## Token 生态的合约集
		-
- # 区块链
	- ## 以太坊节点类型
		- full 全节点：完整数据 500GB
		- Light 轻节点：区块头数据
		- 存档节点：保存整个链的状态，17TB
	- ## 内存池
		- 节点会对对用户发起的交易进行签名验证和检查，检查结束后会把交易放到节点的内存池，但出块后，节点会重新检查内存池，将无效的交易移除
		- 内存池基本都是节点的内存中保存，所以叫内存池
		- 每个节点内存池都可能不同，一个交易也可能存在于多个内存池
		- 节点会从内存池中挑选 gas fee 最高的交易
		- 如何监听内存池
			- 搭建全节点
			- 使用第三方节点
- # Solidity
	- 私有、内部、公共和外部函数之间的区别
		- private：只能当前合约使用，子合约继承也不能调用
		- internal：当前合约和子合约调用
		- public：都可以
		- external：只能外部调用
		- 为什么 `public`比`external` Gas 消耗高？
			- `public`在调用时，会将所有的参数复制到堆栈，在执行时和完成后会清理堆栈，这会导致更多的gas 消耗
				- public 处理过程`calldatacopy` -> `pop``push``swap`->`mstore`
	- 智能合约大小
		- 上海升级之后是 48kb，原来是24kb，与EIP-3860 相关
	- Solidity 0.8.0 版本对算术运算有什么重大变化？
		- 0.8.0 开始，算术运算会在溢出时直接失败回滚
	- call、delegatecall 和 callcode
		- call：合约间调用
		- delegatecall：允许在本合约的上下文中，调用其他合约的代码，实现代理模式
		- callcode：用的比较少，已被启用，会丢弃当前合约的上下文，并将所有状态变量和状态修改应用到目标合约中
	- transfer sender call 的区别
		- | 方法| Gas 限制 | 返回 | 失败 | 限制|
		  |transfer| 2300 | void |失败会 revert | 实现 receive() 或 fallback() ，可以防止重入，但是会导致发送失败|
		  | sender | 2300 | bool | -  | 同 transfer |
		  | call | 自己配置 | bool | - | data 为空时会触发 fallback ，会导致重入 |
	- 以太坊交易的成本如何计算
		- EIP1559 之前，交易成本由矿工通过拍卖机制决定，价高者优先打包
		- EIP1559 之后，取决于 base fee和 tip fee，
	- 区块链随机数
		- 区块链上创建随机数面试的主要挑战是确保随机数的公平性和真实性。由于区块链具有可追溯和不可篡改的特性，生成真正的随机数非常困难
			- 可预测性：区块链上所有交易是公开可见的，攻击者可以通过调整输入参数和执行顺序影响和预测结果
			- 中心化问题：单一的实体生成随机数会引入中心化风险
			- gas 费用较高：随机数需要大量计算，可能导致高昂的 Gas fee
		- 方案
			- 可验证随机数生成器，例如 Chainlink，通过外部输入随机数种子，并且可以验证随机数的公平性
	- 使用 mapping 还是数组更好？
		- mapping 适用于快速查找地址，使用哈希表实现，可以在 O(1) 内查找到数据，可以避免遍历整个列表
		- 数组：小型的list，容易遍历
	- 为什么不应该使用 tx.origin 进行身份验证？
		- origin 是交易的原始发起者，合约有可能是被其他合约调用的，所以需要用 sender
	- fallback 和 receive 之间有什么区别？
		- fallback：函数不存在时触发，加 payable 时，可以接受ETH
		- receiver：接受到以太币时触发，纯转账时调用，必须加 payable，可以接受ETH、
	- constant 和 immutable
		- constant：声明时赋值，保存在 bytecode
		- immutable：construcor 中赋值，且只有一次，保存在 storage
	- Stake Too Deep
		- 原因：EVM 的作用域内，栈内存最多可以引用 16 个变量
		- https://soliditydeveloper.com/stacktoodeep
		- 使用内部方法
		- 使用块级作用域
		- 使用 struct
	- selfdestruct
		- 转移 ETH → 存储和状态移出
	- cold read 和 warm read
		- 冷读是指第一次读取变量，需要从内存中读取其值然后存储到堆栈，会消耗较高的 gas fee
		- Gas Calculation:
			- `gas_cost = 100` **if** `(context_addr, target_storage_key)` **in** `touched_storage_slots` (warm access)
			- `gas_cost = 2100` **if** `(context_addr, target_storage_key)` **not in** `touched_storage_slots` (cold access)
	- [[EVM Gas 优化]]
	- modifer 和 internal function 的选择
		- modifer：将字节码注入到使用的地方
		- internal：跳转到运行时代码
	-
		-
- # DApp
	- ## Defi
		- 闪电贷
			- 无抵押借贷的defi 产品，它允许在一个交易内进行借款和还款，只需要支付一点手续费，用于攻击和套利
		- [[uniswap]]
	- ## L2
		- zkSync 原理
	- ## 钱包
		- [[多签钱包 Safe Wallet]]
		- TODO [[AA 钱包]]
		- TODO [[MPC 钱包]]
	- 白名单如何实现
-
- # 安全
- [[区块链安全集]]
	-
		-